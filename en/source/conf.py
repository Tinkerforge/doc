# -*- coding: utf-8 -*-
#
# Tinkerforge documentation build configuration file, created by
# sphinx-quickstart on Fri Apr 29 12:57:06 2011.
#
# This file is execfile()d with the current directory set to its containing dir.
#
# Note that not all possible configuration values are present in this
# autogenerated file.
#
# All configuration values have a default; values that are commented out
# serve to show the default.

import sys, os, socket

# If extensions (or modules to document with autodoc) are in another directory,
# add these directories to sys.path here. If the directory is relative to the
# documentation root, use os.path.abspath to make it absolute, like shown here.
sys.path.append(os.path.join(os.path.split(__file__)[0], '../..'))


# -- General configuration -----------------------------------------------------

# Add any Sphinx extension module names here, as strings. They can be extensions
# coming with Sphinx (named 'sphinx.ext.*') or your custom ones.
extensions = ['sphinxextra.customhtml',
              'sphinxextra.csharpdomain',
              'sphinxextra.delphidomain',
              'sphinxextra.godomain',
              'sphinxextra.labviewdomain',
              'sphinxextra.javadomain',
              'sphinxextra.javascriptdomain',
              'sphinxextra.mathematicadomain',
              'sphinxextra.matlabdomain',
              'sphinxextra.mqttdomain',
              'sphinxextra.modbusdomain',
              'sphinxextra.openhabdomain',
              'sphinxextra.perldomain',
              'sphinxextra.phpdomain',
              'sphinxextra.rubydomain',
              'sphinxextra.rustdomain',
              'sphinxextra.shelldomain',
              'sphinxextra.tcpipdomain',
              'sphinxextra.tvpldomain',
              'sphinxextra.vbnetdomain',
              'sphinxcontrib.spelling']

# Spell Check Stuff
spelling_lang='en_US'
spelling_word_list_filename='good_wordlist.txt'
spelling_ignore_pypi_package_names = False
spelling_ignore_wiki_words = False
spelling_ignore_acronyms = False
spelling_ignore_python_builtins = False
spelling_ignore_importable_modules = False

# Add any paths that contain templates here, relative to this directory.
templates_path = ['_templates']

# The suffix of source filenames.
source_suffix = '.rst'

# The encoding of source files.
#source_encoding = 'utf-8'

# The master toctree document.
master_doc = 'index'

# General information about the project.
project = u'Tinkerforge'
copyright = u'2011-2016, Olaf Lüke (olaf@tinkerforge.com)'

# The version info for the project you're documenting, acts as replacement for
# |version| and |release|, also used in various other places throughout the
# built documents.
#
# The short X.Y version.
version = '1.0'
# The full version, including alpha/beta/rc tags.
release = '1.0'

# The language for content autogenerated by Sphinx. Refer to documentation
# for a list of supported languages.
language = 'en_US'

# There are two options for replacing |today|: either, you set today to some
# non-false value, then it is used:
#today = ''
# Else, today_fmt is used as the format for a strftime call.
#today_fmt = '%B %d, %Y'

# List of documents that shouldn't be included in the build.
#unused_docs = []

# List of directories, relative to source directory, that shouldn't be searched
# for source files.
exclude_trees = []

# The reST default role (used for this markup: `text`) to use for all documents.
#default_role = None

# If true, '()' will be appended to :func: etc. cross-reference text.
#add_function_parentheses = True

# If true, the current module name will be prepended to all description
# unit titles (such as .. function::).
#add_module_names = True

# If true, sectionauthor and moduleauthor directives will be shown in the
# output. They are ignored by default.
#show_authors = False

# The name of the Pygments (syntax highlighting) style to use.
pygments_style = 'sphinx'

# A list of ignored prefixes for module index sorting.
#modindex_common_prefix = []


# -- Options for HTML output ---------------------------------------------------

# The theme to use for HTML and HTML Help pages.  Major themes that come with
# Sphinx are currently 'default' and 'sphinxdoc'.
#html_theme = 'nature'
html_theme = 'theme_tf'
#html_theme = 'haiku'

# Theme options are theme-specific and customize the look and feel of a theme
# further.  For a list of options available for each theme, see the
# documentation.
#html_theme_options = {"rightsidebar": "true"}

# Add any paths that contain custom themes here, relative to this directory.
html_theme_path = ["."]

# The name for this set of Sphinx documents.  If None, it defaults to
# "<project> v<release> documentation".
html_title = "Tinkerforge"

# A shorter title for the navigation bar.  Default is the same as html_title.
#html_short_title = None

# The name of an image file (relative to this directory) to place at the top
# of the sidebar.
#html_logo = None

# The name of an image file (within the static path) to use as favicon of the
# docs.  This file should be a Windows icon file (.ico) being 16x16 or 32x32
# pixels large.
#html_favicon = None

# Add any paths that contain custom static files (such as style sheets) here,
# relative to this directory. They are copied after the builtin static files,
# so a file named "default.css" will overwrite the builtin "default.css".
html_static_path = ['_static']

# If not '', a 'Last updated on:' timestamp is inserted at every page bottom,
# using the given strftime format.
#html_last_updated_fmt = '%b %d, %Y'

# If true, SmartyPants will be used to convert quotes and dashes to
# typographically correct entities.
#html_use_smartypants = True

# Custom sidebar templates, maps document names to template names.
#html_sidebars = {}

# Additional templates that should be rendered to pages, maps page names to
# template names.
#html_additional_pages = {}

# If false, no module index is generated.
#html_use_modindex = True

# If false, no index is generated.
html_use_index = False

# If true, the index is split into individual pages for each letter.
#html_split_index = False

# If true, links to the reST sources are added to the pages.
#html_show_sourcelink = True

# If true, an OpenSearch description file will be output, and all pages will
# contain a <link> tag referring to it.  The value of this option must be the
# base URL from which the finished HTML is served.
#html_use_opensearch = ''

# If nonempty, this is the file name suffix for HTML files (e.g. ".xhtml").
#html_file_suffix = ''

# Output file base name for HTML help builder.
htmlhelp_basename = 'Tinkerforgedoc'


# -- Options for LaTeX output --------------------------------------------------

# The paper size ('letter' or 'a4').
#latex_paper_size = 'letter'

# The font size ('10pt', '11pt' or '12pt').
#latex_font_size = '10pt'

# Grouping the document tree into LaTeX files. List of tuples
# (source start file, target name, title, author, documentclass [howto/manual]).
latex_documents = [
  ('index', 'Tinkerforge.tex', u'Tinkerforge',
   u'Olaf Lüke (olaf@tinkerforge.com)', 'manual'),
]

# The name of an image file (relative to this directory) to place at the top of
# the title page.
#latex_logo = None

# For "manual" documents, if this is true, then toplevel headings are parts,
# not chapters.
#latex_use_parts = False

# Additional stuff for the LaTeX preamble.
#latex_preamble = ''

# Documents to append as an appendix to all manuals.
#latex_appendices = []

# If false, no module index is generated.
#latex_use_modindex = True


# -- Options for gettext output -----------------------------------------------

gettext_auto_build = False


# -- Monkey patch pygments ----------------------------------------------------

# The Perl lexer wrongly parses any two slashed as a regex, even if one slash is
# in a division and the other one is in a string, for example:
#
# print "Acceleration [X]: " . @{$acceleration}[0]/100.0 . " m/s²\n";
#
# Completely remove regex parsing from the Perl lexer to workaround this problem.

from pygments.lexers.perl import PerlLexer as PygmentsPerlLexer
from pygments.token import String as PygmentsString

PygmentsPerlLexer.tokens.pop('balanced-regex', None)

# Use Rust lexer from Pygments 2.2.0 to fix some Rust parsing errors
for i in reversed(range(len(PygmentsPerlLexer.tokens['root']))):
    if PygmentsPerlLexer.tokens['root'][i][1] == PygmentsString.Regex:
        del PygmentsPerlLexer.tokens['root'][i]

from sphinxextra.pygments_rust_fixed import RustLexerFixed as PygmentsRustLexerFixed
import pygments.lexers.rust

pygments.lexers.rust.RustLexer = PygmentsRustLexerFixed


# -- Monkey patch sphinx ------------------------------------------------------

def setup(app):
    import os
    import sphinx
    from packaging.version import Version
    from docutils import nodes
    from sphinx import addnodes
    from sphinx.environment import BuildEnvironment

    from sphinx.util import url_re
    from sphinx.util.nodes import clean_astext

    # Use html-page-context event to add the breadcrumbs function to template context
    # Note: In Sphinx 7.x, add_sidebars is defined but never called, so we use this event instead
    def add_breadcrumbs_to_context(app, pagename, templatename, context, doctree):
        builder = app.builder
        env = app.env

        def get_breadcrumbs(separator):
            if not hasattr(env, 'monkey_breadcrumbs'):
                return ''

            if pagename not in env.monkey_breadcrumbs:
                return ''

            links = []
            breadcrumbs = env.monkey_breadcrumbs[pagename]

            for ref, anchor, title in breadcrumbs[:-1]:
                ref_parts = os.path.split('/' + ref)
                links.append('<a href="{0}/{1}.html{2}">{3}</a>'.format(os.path.relpath(ref_parts[0], os.path.split('/' + pagename)[0]), ref_parts[1], anchor, title))

            links.append(breadcrumbs[-1][2])

            return separator.join(links)

        context['breadcrumbs'] = get_breadcrumbs

    app.connect('html-page-context', add_breadcrumbs_to_context)

    # hook into BuildEnvironment.resolve_toctree to modify toctree generation
    def monkey_get_reverse_toctree(self): # self == BuildEnvironment
        toctrees = list(self.get_doctree(self.config.master_doc).traverse(addnodes.toctree))
        master = toctrees[0]

        for toctree in toctrees[1:]:
            master.extend(toctree.children)

        def expand_toctree(node):
            expanded = {}

            for entry in node['entries']:
                title = entry[0]
                ref = entry[1]

                for toctree in self.tocs[ref].traverse(addnodes.toctree):
                    for key, value in expand_toctree(toctree).items():
                        if ref not in expanded:
                            expanded[ref] = {}

                        if key in expanded[ref]:
                            raise Exception('Duplicate toctree node ' + key + ' in ' + ref)

                        expanded[ref][key] = value

                if ref not in expanded:
                    expanded[ref] = None

            return expanded

        expanded_toctree = expand_toctree(master)

        def expand_reverse(node, path):
            expanded = {}

            for key, value in node.items():
                if key in expanded:
                    raise Exception('Duplicate toctree leaf ' + key)

                expanded[key] = path

                if value != None:
                    for subkey, subvalue in expand_reverse(value, path + [key]).items():
                        if subkey in expanded:
                            raise Exception('Duplicate toctree leaf ' + subkey)

                        expanded[subkey] = subvalue

            return expanded

        return expand_reverse(expanded_toctree, [])

    BuildEnvironment.monkey_get_reverse_toctree = monkey_get_reverse_toctree

    # this code originally comes from sphinx 1.2.2
    def new_resolve_toctree_v122(self, docname, builder, toctree, prune=True, maxdepth=0,
                                 titles_only=False, collapse=False, includehidden=False):
        """Resolve a *toctree* node into individual bullet lists with titles
        as items, returning None (if no containing titles are found) or
        a new node.

        If *prune* is True, the tree is pruned to *maxdepth*, or if that is 0,
        to the value of the *maxdepth* option on the *toctree* node.
        If *titles_only* is True, only toplevel document titles will be in the
        resulting tree.
        If *collapse* is True, all branches not containing docname will
        be collapsed.
        """

        if toctree.get('hidden', False) and not includehidden:
            return None

        # photron: prepare reverse toctree lookup to avoid expaning the whole
        # tree every time. only expand the path to the current document
        if not hasattr(self, 'monkey_reverse_toctree'):
            self.monkey_reverse_toctree = self.monkey_get_reverse_toctree()
        # photron: end

        # For reading the following two helper function, it is useful to keep
        # in mind the node structure of a toctree (using HTML-like node names
        # for brevity):
        #
        # <ul>
        #   <li>
        #     <p><a></p>
        #     <p><a></p>
        #     ...
        #     <ul>
        #       ...
        #     </ul>
        #   </li>
        # </ul>
        #
        # The transformation is made in two passes in order to avoid
        # interactions between marking and pruning the tree (see bug #1046).

        def _toctree_prune_v122(node, depth, maxdepth):
            """Utility: Cut a TOC at a specified depth."""
            for subnode in node.children[:]:
                if isinstance(subnode, (addnodes.compact_paragraph,
                                        nodes.list_item)):
                    # for <p> and <li>, just recurse
                    _toctree_prune_v122(subnode, depth, maxdepth)
                elif isinstance(subnode, nodes.bullet_list):
                    # for <ul>, determine if the depth is too large or if the
                    # entry is to be collapsed
                    if maxdepth > 0 and depth > maxdepth:
                        subnode.parent.replace(subnode, [])
                    else:
                        mindepth = 2 # photron: keep the first level expanded, was set to 1 before
                        # cull sub-entries whose parents aren't 'current'
                        if (collapse and depth > mindepth and
                            'iscurrent' not in subnode.parent):
                            subnode.parent.remove(subnode)
                        else:
                            # recurse on visible children
                            _toctree_prune_v122(subnode, depth+1, maxdepth)

        def _toctree_add_classes_v122(node, depth):
            """Add 'toctree-l%d' and 'current' classes to the toctree."""

            # photron: start
            if not hasattr(self, 'monkey_breadcrumbs'):
                self.monkey_breadcrumbs = {}
            # photron: end

            for subnode in node.children:
                if isinstance(subnode, (addnodes.compact_paragraph,
                                        nodes.list_item)):
                    # for <p> and <li>, indicate the depth level and recurse
                    subnode['classes'].append('toctree-l%d' % (depth-1))
                    _toctree_add_classes_v122(subnode, depth)
                elif isinstance(subnode, nodes.bullet_list):
                    # for <ul>, just recurse
                    _toctree_add_classes_v122(subnode, depth+1)
                elif isinstance(subnode, nodes.reference):
                    # for <a>, identify which entries point to the current
                    # document and therefore may not be collapsed
                    if subnode['refuri'] == docname:
                        if not subnode['anchorname']:
                            # photron: start
                            breadcrumbs = []
                            # photron: end

                            # give the whole branch a 'current' class
                            # (useful for styling it differently)
                            branchnode = subnode
                            while branchnode:
                                branchnode['classes'].append('current')
                                branchnode = branchnode.parent

                                # photron: collect current path in toctree as breadcrumbs
                                if branchnode and isinstance(branchnode, nodes.list_item):
                                    for c in branchnode.traverse(nodes.reference):
                                        if len(c.children) == 0:
                                            raise Exception('Missing reference text node id breadcrumbs for ' + docname)

                                        breadcrumbs = [(c['refuri'], c['anchorname'], c.children[0].astext())] + breadcrumbs
                                        break
                                # photron: end

                            # photron: sanity check
                            if docname in self.monkey_breadcrumbs and self.monkey_breadcrumbs[docname] != breadcrumbs:
                               raise Exception('Different breadcrumbs for ' + docname)

                            self.monkey_breadcrumbs[docname] = breadcrumbs
                            # photron: end

                        # mark the list_item as "on current page"
                        if subnode.parent.parent.get('iscurrent'):
                            # but only if it's not already done
                            return
                        while subnode:
                            subnode['iscurrent'] = True
                            subnode = subnode.parent

        def _entries_from_toctree_v122(toctreenode, parents,
                                       separate=False, subtree=False,
                                       # photron: add forced_expand option to force expansion
                                       # one sublevel below the path to the current document
                                       forced_expand=False):
                                       # photron: end
            """Return TOC entries for a toctree node."""
            refs = [(e[0], e[1]) for e in toctreenode['entries']]
            entries = []
            for (title, ref) in refs:
                if title != None and title.startswith('~'):
                    continue

                try:
                    refdoc = None
                    if url_re.match(ref):
                        reference = nodes.reference('', '', internal=False,
                                                    refuri=ref, anchorname='',
                                                    *[nodes.Text(title)])
                        para = addnodes.compact_paragraph('', '', reference)
                        item = nodes.list_item('', para)
                        toc = nodes.bullet_list('', item)
                    elif ref == 'self':
                        # 'self' refers to the document from which this
                        # toctree originates
                        ref = toctreenode['parent']
                        if not title:
                            title = clean_astext(self.titles[ref])
                        reference = nodes.reference('', '', internal=True,
                                                    refuri=ref,
                                                    anchorname='',
                                                    *[nodes.Text(title)])
                        para = addnodes.compact_paragraph('', '', reference)
                        item = nodes.list_item('', para)
                        # don't show subitems
                        toc = nodes.bullet_list('', item)
                    else:
                        if ref in parents:
                            self.warn(ref, 'circular toctree references '
                                      'detected, ignoring: %s <- %s' %
                                      (ref, ' <- '.join(parents)))
                            continue
                        refdoc = ref
                        toc = self.tocs[ref].deepcopy()
                        self.process_only_nodes(toc, builder, ref)
                        if title and toc.children and len(toc.children) == 1:
                            child = toc.children[0]
                            for refnode in child.traverse(nodes.reference):
                                if refnode['refuri'] == ref and \
                                       not refnode['anchorname']:
                                    refnode.children = [nodes.Text(title)]
                    if not toc.children:
                        # empty toc means: no titles will show up in the toctree
                        self.warn_node(
                            'toctree contains reference to document %r that '
                            'doesn\'t have a title: no link will be generated'
                            % ref, toctreenode)
                except KeyError:
                    # this is raised if the included file does not exist
                    self.warn_node(
                        'toctree contains reference to nonexisting document %r'
                        % ref, toctreenode)
                else:
                    # if titles_only is given, only keep the main title and
                    # sub-toctrees
                    if titles_only:
                        # delete everything but the toplevel title(s)
                        # and toctrees
                        for toplevel in toc:
                            # nodes with length 1 don't have any children anyway
                            if len(toplevel) > 1:
                                subtrees = toplevel.traverse(addnodes.toctree)
                                toplevel[1][:] = subtrees
                    # resolve all sub-toctrees
                    for toctreenode in toc.traverse(addnodes.toctree):
                        if not (toctreenode.get('hidden', False)
                                and not includehidden):

                            # photron: use the reverse toctree lookup to only expand
                            # nodes along the way to the current document
                            if docname != 'index':
                                if docname not in self.monkey_reverse_toctree:
                                    continue

                                if not forced_expand and refdoc not in self.monkey_reverse_toctree[docname]:
                                    continue
                            # photron: end

                            # photron: force sublevel for the index and other toplevel documents,
                            # also force it for one sublevel below the path to the current document
                            next_forced_expand = \
                                docname == 'index' or \
                                len(self.monkey_reverse_toctree[docname]) == 0 or \
                                refdoc == self.monkey_reverse_toctree[docname][-1]
                            # photron: end

                            i = toctreenode.parent.index(toctreenode) + 1
                            for item in _entries_from_toctree_v122(
                                    toctreenode, [refdoc] + parents,
                                    subtree=True,
                                    # photron: start
                                    forced_expand=next_forced_expand):
                                    # photron: end
                                toctreenode.parent.insert(i, item)
                                i += 1
                            toctreenode.parent.remove(toctreenode)
                    if separate:
                        entries.append(toc)
                    else:
                        entries.extend(toc.children)
            if not subtree and not separate:
                ret = nodes.bullet_list()
                ret += entries
                return [ret]
            return entries

        maxdepth = maxdepth or toctree.get('maxdepth', -1)
        if not titles_only and toctree.get('titlesonly', False):
            titles_only = True
        if not includehidden and toctree.get('includehidden', False):
            includehidden = True

        # NOTE: previously, this was separate=True, but that leads to artificial
        # separation when two or more toctree entries form a logical unit, so
        # separating mode is no longer used -- it's kept here for history's sake
        tocentries = _entries_from_toctree_v122(toctree, [], separate=False,
                                                # photron: add forced_expand option to force expansion
                                                forced_expand=True)
                                                # photron: end
        if not tocentries:
            return None

        newnode = addnodes.compact_paragraph('', '', *tocentries)
        newnode['toctree'] = True

        # prune the tree to maxdepth, also set toc depth and current classes
        _toctree_add_classes_v122(newnode, 1)
        _toctree_prune_v122(newnode, 1, prune and maxdepth or 0)

        # set the target paths in the toctrees (they are not known at TOC
        # generation time)
        for refnode in newnode.traverse(nodes.reference):
            if not url_re.match(refnode['refuri']):
                refnode['refuri'] = builder.get_relative_uri(
                    docname, refnode['refuri']) + refnode['anchorname']

                # photron: empty refuri doesn't work in IE, use a # instead
                if len(refnode['refuri']) == 0:
                    refnode['refuri'] = '#'
                # photron: end

        return newnode

    # this code originally comes from sphinx 1.5.3
    def new_resolve_toctree_v153(self, docname, builder, toctree, prune=True, maxdepth=0,
                                 titles_only=False, collapse=False, includehidden=False):
        """Resolve a *toctree* node into individual bullet lists with titles
        as items, returning None (if no containing titles are found) or
        a new node.

        If *prune* is True, the tree is pruned to *maxdepth*, or if that is 0,
        to the value of the *maxdepth* option on the *toctree* node.
        If *titles_only* is True, only toplevel document titles will be in the
        resulting tree.
        If *collapse* is True, all branches not containing docname will
        be collapsed.
        """
        if toctree.get('hidden', False) and not includehidden:
            return None

        # photron: prepare reverse toctree lookup to avoid expaning the whole
        # tree every time. only expand the path to the current document
        if not hasattr(self.env, 'monkey_reverse_toctree'):
            self.env.monkey_reverse_toctree = self.env.monkey_get_reverse_toctree()
        # photron: end

        from sphinx.util.nodes import process_only_nodes

        # For reading the following two helper function, it is useful to keep
        # in mind the node structure of a toctree (using HTML-like node names
        # for brevity):
        #
        # <ul>
        #   <li>
        #     <p><a></p>
        #     <p><a></p>
        #     ...
        #     <ul>
        #       ...
        #     </ul>
        #   </li>
        # </ul>
        #
        # The transformation is made in two passes in order to avoid
        # interactions between marking and pruning the tree (see bug #1046).

        toctree_ancestors = self.get_toctree_ancestors(docname)

        def _toctree_add_classes_v153(node, depth):
            """Add 'toctree-l%d' and 'current' classes to the toctree."""

            # photron: start
            if not hasattr(self.env, 'monkey_breadcrumbs'):
                self.env.monkey_breadcrumbs = {}
            # photron: end

            for subnode in node.children:
                if isinstance(subnode, (addnodes.compact_paragraph,
                                        nodes.list_item)):
                    # for <p> and <li>, indicate the depth level and recurse
                    subnode['classes'].append('toctree-l%d' % (depth - 1))
                    _toctree_add_classes_v153(subnode, depth)
                elif isinstance(subnode, nodes.bullet_list):
                    # for <ul>, just recurse
                    _toctree_add_classes_v153(subnode, depth + 1)
                elif isinstance(subnode, nodes.reference):
                    # for <a>, identify which entries point to the current
                    # document and therefore may not be collapsed
                    if subnode['refuri'] == docname:
                        if not subnode['anchorname']:
                            # photron: start
                            breadcrumbs = []
                            # photron: end

                            # give the whole branch a 'current' class
                            # (useful for styling it differently)
                            branchnode = subnode
                            while branchnode:
                                branchnode['classes'].append('current')
                                branchnode = branchnode.parent

                                # photron: collect current path in toctree as breadcrumbs
                                if branchnode and isinstance(branchnode, nodes.list_item):
                                    for c in branchnode.traverse(nodes.reference):
                                        if len(c.children) == 0:
                                            raise Exception('Missing reference text node id breadcrumbs for ' + docname)

                                        breadcrumbs = [(c['refuri'], c['anchorname'], c.children[0].astext())] + breadcrumbs
                                        break
                                # photron: end

                            # photron: sanity check
                            if docname in self.env.monkey_breadcrumbs and self.env.monkey_breadcrumbs[docname] != breadcrumbs:
                               raise Exception('Different breadcrumbs for ' + docname)

                            self.env.monkey_breadcrumbs[docname] = breadcrumbs
                            # photron: end

                        # mark the list_item as "on current page"
                        if subnode.parent.parent.get('iscurrent'):
                            # but only if it's not already done
                            return
                        while subnode:
                            subnode['iscurrent'] = True
                            subnode = subnode.parent

        def _entries_from_toctree_v153(toctreenode, parents,
                                       separate=False, subtree=False,
                                       # photron: add forced_expand option to force expansion
                                       # one sublevel below the path to the current document
                                       forced_expand=False):
                                       # photron: end
            """Return TOC entries for a toctree node."""
            refs = [(e[0], e[1]) for e in toctreenode['entries']]
            entries = []
            for (title, ref) in refs:
                if title != None and title.startswith('~'):
                    continue

                try:
                    refdoc = None
                    if url_re.match(ref):
                        if title is None:
                            title = ref
                        reference = nodes.reference('', '', internal=False,
                                                    refuri=ref, anchorname='',
                                                    *[nodes.Text(title)])
                        para = addnodes.compact_paragraph('', '', reference)
                        item = nodes.list_item('', para)
                        toc = nodes.bullet_list('', item)
                    elif ref == 'self':
                        # 'self' refers to the document from which this
                        # toctree originates
                        ref = toctreenode['parent']
                        if not title:
                            title = clean_astext(self.env.titles[ref])
                        reference = nodes.reference('', '', internal=True,
                                                    refuri=ref,
                                                    anchorname='',
                                                    *[nodes.Text(title)])
                        para = addnodes.compact_paragraph('', '', reference)
                        item = nodes.list_item('', para)
                        # don't show subitems
                        toc = nodes.bullet_list('', item)
                    else:
                        if ref in parents:
                            self.env.warn(ref, 'circular toctree references '
                                          'detected, ignoring: %s <- %s' %
                                          (ref, ' <- '.join(parents)))
                            continue
                        refdoc = ref
                        toc = self.tocs[ref].deepcopy()
                        maxdepth = self.env.metadata[ref].get('tocdepth', 0)
                        if ref not in toctree_ancestors or (prune and maxdepth > 0):
                            self._toctree_prune(toc, 2, maxdepth, collapse)
                        process_only_nodes(toc, builder.tags, warn_node=self.env.warn_node)
                        if title and toc.children and len(toc.children) == 1:
                            child = toc.children[0]
                            for refnode in child.traverse(nodes.reference):
                                if refnode['refuri'] == ref and \
                                   not refnode['anchorname']:
                                    refnode.children = [nodes.Text(title)]
                    if not toc.children:
                        # empty toc means: no titles will show up in the toctree
                        self.env.warn_node(
                            'toctree contains reference to document %r that '
                            'doesn\'t have a title: no link will be generated'
                            % ref, toctreenode)
                except KeyError:
                    # this is raised if the included file does not exist
                    self.env.warn_node(
                        'toctree contains reference to nonexisting document %r'
                        % ref, toctreenode)
                else:
                    # if titles_only is given, only keep the main title and
                    # sub-toctrees
                    if titles_only:
                        # delete everything but the toplevel title(s)
                        # and toctrees
                        for toplevel in toc:
                            # nodes with length 1 don't have any children anyway
                            if len(toplevel) > 1:
                                subtrees = toplevel.traverse(addnodes.toctree)
                                if subtrees:
                                    toplevel[1][:] = subtrees
                                else:
                                    toplevel.pop(1)
                    # resolve all sub-toctrees
                    for subtocnode in toc.traverse(addnodes.toctree):
                        if not (subtocnode.get('hidden', False) and
                                not includehidden):

                            # photron: use the reverse toctree lookup to only expand
                            # nodes along the way to the current document
                            if docname != 'index':
                                if docname not in self.env.monkey_reverse_toctree:
                                    continue

                                if not forced_expand and refdoc not in self.env.monkey_reverse_toctree[docname]:
                                    continue
                            # photron: end

                            # photron: force sublevel for the index and other toplevel documents,
                            # also force it for one sublevel below the path to the current document
                            next_forced_expand = \
                                docname == 'index' or \
                                len(self.env.monkey_reverse_toctree[docname]) == 0 or \
                                refdoc == self.env.monkey_reverse_toctree[docname][-1]
                            # photron: end

                            i = subtocnode.parent.index(subtocnode) + 1
                            for item in _entries_from_toctree_v153(
                                    subtocnode, [refdoc] + parents,
                                    subtree=True,
                                    # photron: start
                                    forced_expand=next_forced_expand):
                                    # photron: end
                                subtocnode.parent.insert(i, item)
                                i += 1
                            subtocnode.parent.remove(subtocnode)
                    if separate:
                        entries.append(toc)
                    else:
                        entries.extend(toc.children)
            if not subtree and not separate:
                ret = nodes.bullet_list()
                ret += entries
                return [ret]
            return entries

        maxdepth = maxdepth or toctree.get('maxdepth', -1)
        if not titles_only and toctree.get('titlesonly', False):
            titles_only = True
        if not includehidden and toctree.get('includehidden', False):
            includehidden = True

        # NOTE: previously, this was separate=True, but that leads to artificial
        # separation when two or more toctree entries form a logical unit, so
        # separating mode is no longer used -- it's kept here for history's sake
        tocentries = _entries_from_toctree_v153(toctree, [], separate=False,
                                               # photron: add forced_expand option to force expansion
                                               forced_expand=True)
                                               # photron: end
        if not tocentries:
            return None

        newnode = addnodes.compact_paragraph('', '')
        caption = toctree.attributes.get('caption')
        if caption:
            caption_node = nodes.caption(caption, '', *[nodes.Text(caption)])
            caption_node.line = toctree.line
            caption_node.source = toctree.source
            caption_node.rawsource = toctree['rawcaption']
            if hasattr(toctree, 'uid'):
                # move uid to caption_node to translate it
                caption_node.uid = toctree.uid
                del toctree.uid
            newnode += caption_node
        newnode.extend(tocentries)
        newnode['toctree'] = True

        # prune the tree to maxdepth, also set toc depth and current classes
        _toctree_add_classes_v153(newnode, 1)
        self._toctree_prune(newnode, 1, prune and maxdepth or 0, collapse)

        if len(newnode[-1]) == 0:  # No titles found
            return None

        # set the target paths in the toctrees (they are not known at TOC
        # generation time)
        for refnode in newnode.traverse(nodes.reference):
            if not url_re.match(refnode['refuri']):
                refnode['refuri'] = builder.get_relative_uri(
                    docname, refnode['refuri']) + refnode['anchorname']

                # photron: empty refuri doesn't work in IE, use a # instead
                if len(refnode['refuri']) == 0:
                    refnode['refuri'] = '#'
                # photron: end

        return newnode

    # this code originally comes from sphinx 1.5.3
    def new_toctree_prune_v153(self, node, depth, maxdepth, collapse=False):
        """Utility: Cut a TOC at a specified depth."""
        for subnode in node.children[:]:
            if isinstance(subnode, (addnodes.compact_paragraph,
                                    nodes.list_item)):
                # for <p> and <li>, just recurse
                self._toctree_prune(subnode, depth, maxdepth, collapse)
            elif isinstance(subnode, nodes.bullet_list):
                # for <ul>, determine if the depth is too large or if the
                # entry is to be collapsed
                if maxdepth > 0 and depth > maxdepth:
                    subnode.parent.replace(subnode, [])
                else:
                    mindepth = 2 # photron: keep the first level expanded, was set to 1 before
                    # cull sub-entries whose parents aren't 'current'
                    if (collapse and depth > mindepth and
                        'iscurrent' not in subnode.parent):
                        subnode.parent.remove(subnode)
                    else:
                        # recurse on visible children
                        self._toctree_prune(subnode, depth + 1, maxdepth, collapse)

    if Version(sphinx.__version__) < Version('1.5.0'):
        BuildEnvironment.resolve_toctree = new_resolve_toctree_v122
    elif Version(sphinx.__version__) < Version('7.0.0'):
        from sphinx.environment.managers.toctree import Toctree
        Toctree.resolve_toctree = new_resolve_toctree_v153
        Toctree._toctree_prune = new_toctree_prune_v153
    else:
        # Sphinx 7.x: patch _toctree_copy to keep first level expanded (mindepth=2)
        # In Sphinx 7.x, _toctree_prune was replaced by _toctree_copy
        from sphinx.environment.adapters import toctree as toctree_module

        _original_toctree_copy = toctree_module._toctree_copy

        def _patched_toctree_copy(node, depth, maxdepth, collapse, tags):
            """
            Original logic:
                keep = (depth <= 1 or ((depth <= maxdepth or maxdepth <= 0)
                        and (not collapse or 'iscurrent' in node)))

            Patched logic:
                keep = (depth <= 2 or ((depth <= maxdepth or maxdepth <= 0)
                        and (not collapse or 'iscurrent' in node)))
            """
            mindepth = 2
            keep_bullet_list_sub_nodes = (depth <= mindepth
                                          or ((depth <= maxdepth or maxdepth <= 0)
                                              and (not collapse or 'iscurrent' in node)))

            copy = node.copy()
            for subnode in node.children:
                if isinstance(subnode, (addnodes.compact_paragraph, nodes.list_item)):
                    # for <p> and <li>, just recurse
                    copy.append(_patched_toctree_copy(subnode, depth, maxdepth, collapse, tags))
                elif isinstance(subnode, nodes.bullet_list):
                    # for <ul>, copy if the entry is top-level
                    # or, copy if the depth is within bounds and;
                    # collapsing is disabled or the sub-entry's parent is 'current'.
                    if keep_bullet_list_sub_nodes:
                        copy.append(_patched_toctree_copy(subnode, depth + 1, maxdepth, collapse, tags))
                elif isinstance(subnode, addnodes.toctree):
                    # copy sub toctree nodes for later processing
                    copy.append(subnode.copy())
                elif isinstance(subnode, addnodes.only):
                    # only keep children if the only node matches the tags
                    from sphinx.util.nodes import _only_node_keep_children
                    if _only_node_keep_children(subnode, tags):
                        for child in subnode.children:
                            copy.append(_patched_toctree_copy(
                                child, depth, maxdepth, collapse, tags,
                            ))
                elif isinstance(subnode, (nodes.reference, nodes.title)):
                    # deep copy references and captions
                    sub_node_copy = subnode.copy()
                    sub_node_copy.children = [child.deepcopy() for child in subnode.children]
                    for child in sub_node_copy.children:
                        child.parent = sub_node_copy
                    copy.append(sub_node_copy)
                else:
                    msg = f'Unexpected node type {subnode.__class__.__name__!r}!'
                    raise ValueError(msg)
            return copy

        # Apply the patch
        toctree_module._toctree_copy = _patched_toctree_copy
